import Foundation
import os.log

/// Sandboxes commands for secure execution
public struct CommandSandbox {
    /// Logger for tracking sandbox activity
    private let logger = Logger(subsystem: "com.llamaterminal", category: "CommandSandbox")
    
    /// Singleton instance
    public static let shared = CommandSandbox()
    
    /// Security level for command execution
    public enum SecurityLevel {
        case standard   // Default security
        case strict     // Enhanced security for AI generated commands
        case permissive // Reduced security for trusted operations
    }
    
    /// Initialize the sandbox
    private init() {}
    
    /// Sandbox a command for safe execution
    /// - Parameters:
    ///   - command: Command to sandbox
    ///   - securityLevel: Security level to apply
    ///   - isAIGenerated: Whether the command was generated by AI
    /// - Returns: Sandboxed command or nil if command is not allowed
    public func sandboxCommand(
        _ command: String,
        securityLevel: SecurityLevel = .standard,
        isAIGenerated: Bool = false
    ) -> String? {
        // First, validate the command
        guard validateCommand(command, securityLevel: securityLevel) else {
            logger.error("Command rejected by sandbox validation: \(command)")
            return nil
        }
        
        // Apply security measures based on security level
        let sandboxedCommand: String
        
        switch securityLevel {
        case .strict:
            sandboxedCommand = applyStrictSandboxing(command)
        case .standard:
            sandboxedCommand = applyStandardSandboxing(command, isAIGenerated: isAIGenerated)
        case .permissive:
            sandboxedCommand = applyPermissiveSandboxing(command)
        }
        
        // Apply security measures based on security level
        let sandboxedCommand: String
        
        switch securityLevel {
        case .s    /// Validates a command for safety
    /// Validates a command for safety
    /// - Parameters:
    ///   - command: Command to validate
    ///   - securityLevel: Security level to apply
    /// - Returns: Whether the command is allowed
    private func validateCommand(_ command: String, securityLevel: SecurityLevel) -> Bool {
        // List of universally forbidden commands or patterns (security exploits and dangerous operations)
        let forbiddenPatterns = [
            ":(){ :|:& };:",              // Fork bomb
            "rm -rf /*",                   // Delete root
            "rm -rf --no-preserve-root /", // Delete root with no preserve root
            "> /dev/sd",                   // Overwrite disk device
            "dd if=/dev/zero of=/dev/sd",  // Zero out disk
            "dd if=/dev/urandom of=/dev/sd", // Random data to disk
            "mkfs.*dev/sd",                // Format a disk device
            "> /dev/null; rm -rf ",        // Hidden rm
            "curl.* | sudo bash",          // Piping web content to privileged bash
            "wget.* | sudo bash",          // Piping web content to privileged bash
            "chmod -R 777 /",              // Recursive chmod on root
            "chown -R .* /",               // Recursive chown on root
            "> /boot/",                    // Overwrite boot files
            "find / .* -delete",           // Find with delete from root
        ]
        
        // Additional patterns for strict mode
        let strictForbiddenPatterns = [
            "rm -[rRf]",                   // Recursive removal
            "chmod -R",                    // Recursive chmod
            "chown -R",                    // Recursive chown
            "sudo su",                     // Switch to super user
            "sudo -i",                     // Interactive sudo
            "sudo bash",                   // Privileged bash
            "reboot",                      // Reboot system
            "shutdown",                    // Shutdown system
            "halt",                        // Halt system
            "init 0",                      // Shutdown
            "init 6",                      // Reboot
            "systemctl .* reboot",         // Systemctl reboot
            "systemctl .* poweroff",       // Systemctl poweroff
            "> /etc/",                     // Write to system config
            "mv .* /etc/",                 // Move to system config
            "curl.* | bash",               // Piping web content to bash
            "wget.* | bash",               // Piping web content to bash
        ]
        
        // Check against universally forbidden patterns
        for pattern in forbiddenPatterns {
            if commandMatches(command, pattern: pattern) {
                logger.error("Command rejected (forbidden pattern): \(pattern)")
                return false
            }
        }
        
        // Check against strict mode patterns if applicable
        if securityLevel == .strict {
            for pattern in strictForbiddenPatterns {
                if commandMatches(command, pattern: pattern) {
                    logger.error("Command rejected (strict mode pattern): \(pattern)")
                    return false
                }
            }
        }
        
        return true
    /// - Returns: Whether the command matches the pattern
    private func commandMatches(_ command: String, pattern: String) -> Bool {
        if pattern.contains("*") {
            // Simplified glob-like pattern matching
            let escapedPattern = NSRegularExpression.escapedPattern(for: pattern)
            let regexPattern = escapedPattern.replacingOccurrences(of: "\\*", with: ".*")
            
            do {
                let regex = try NSRegularExpression(pattern: regexPattern)
                let range = NSRange(command.startIndex..<command.endIndex, in: command)
                return regex.firstMatch(in: command, range: range) != nil
            } catch {
                logger.error("Regex error: \(error.localizedDescription)")
                // If regex creation fails, fall back to simple contains check
                return command.contains(pattern.replacingOccurrences(of: "*", with: ""))
            }
        } else {
            // Simple substring check
            return command.contains(pattern)
        }
    }
    
    /// Command transformation rule
    public struct TransformationRule {
        /// Type of rule
        public enum RuleType {
            case replace(pattern: String, replacement: String)
            case append(suffix: String, condition: (String) -> Bool)
            case prepend(prefix: String, condition: (String) -> Bool)
            case wrap(prefix: String, suffix: String, condition: (String) -> Bool)
        }
        
        /// The rule to apply
        let rule: RuleType
        
        /// Applies this rule to a command
        /// - Parameter command: Command to transform
        /// - Returns: Transformed command
        func apply(to command: String) -> String {
            switch rule {
            case .replace(let pattern, let replacement):
                return command.replacingOccurrences(of: pattern, with: replacement)
            case .append(let suffix, let condition):
                return condition(command) ? command + suffix : command
            case .prepend(let prefix, let condition):
                return condition(command) ? prefix + command : command
            case .wrap(let prefix, let suffix, let condition):
                return condition(command) ? prefix + command + suffix : command
            }
        }
    }
    
    /// Applies strict sandboxing measures (for AI-generated commands or high-risk operations)
    /// - Parameter command: Original command
    /// - Returns: Sandboxed command
    private func applyStrictSandboxing(_ command: String) -> String {
        // Start with standard sandboxing
        var sandboxedCommand = applyStandardSandboxing(command, isAIGenerated: true)
        
        // Apply strict safeguards
        let strictRules: [TransformationRule] = [
            // Force verbose mode on all operations
            TransformationRule(rule: .append(suffix: " -v", condition: { cmd in
                return !cmd.contains(" -v")
            })),
            // Limit operations to current directory for safety
            TransformationRule(rule: .prepend(prefix: "cd \"$PWD\" && ", condition: { _ in true })),
            // Add strict isolation
            TransformationRule(rule: .wrap(
                prefix: "(\n# Strict sandbox environment\nset -e\nTMPDIR=\"$(mktemp -d)\"\ntrap 'rm -rf \"$TMPDIR\"' EXIT\ncd \"$TMPDIR\"\n\n",
                suffix: "\n) # End of sandbox",
                condition: { cmd in
                    // Only apply to potentially dangerous commands
                    return cmd.contains("rm") || cmd.contains("mv") || cmd.contains(">") || cmd.contains("|")
                }
            )),
        ]
        
        // Apply all strict rules
        for rule in strictRules {
            sandboxedCommand = rule.apply(to: sandboxedCommand)
        }
        
        // Add confirmation prompt for strict mode
        sandboxedCommand = """
        echo "\\033[1;31m[STRICT SANDBOX] About to execute command in restricted environment:\\033[0m"
        echo "\\033[31m\(sandboxedCommand.replacingOccurrences(of: "\"", with: "\\\""))\\033[0m"
        echo -n "Type 'confirm' to proceed: "
        read confirmation
        if [ "$confirmation" = "confirm" ]; then
            \(sandboxedCommand)
        else
            echo "Operation cancelled."
            exit 1
        fi
        """
        
        return sandboxedCommand
    }
    
    /// Applies standard sandboxing measures
    /// - Parameters:
    ///   - command: Original command
    ///   - isAIGenerated: Whether command was AI-generated
    /// - Returns: Sandboxed command
    private func applyStandardSandboxing(_ command: String, isAIGenerated: Bool) -> String {
        // Define standard transformation rules
        let standardRules: [TransformationRule] = [
            // Interactive flag for rm
            TransformationRule(rule: .replace(pattern: "rm ", with: "rm -i "), 
                condition: { cmd in return cmd.hasPrefix("rm ") && !cmd.contains(" -i ") }),
            // Verbose flag for file operations
            TransformationRule(rule: .append(suffix: " -v", condition: { cmd in
                return (cmd.hasPrefix("mv ") || cmd.hasPrefix("cp ")) && !cmd.contains(" -v")
            })),
            // Enable nullglob to avoid wildcard issues
            TransformationRule(rule: .prepend(prefix: "shopt -s nullglob 2>/dev/null || setopt NULL_GLOB 2>/dev/null; ", 
                condition: { cmd in return cmd.contains("*") })),
        ].compactMap { rule in
            // Filter only applicable rules
            if case let .replace(_, _) = rule.rule { return rule }
            if case let .append(_, condition) = rule.rule, condition(command) { return rule }
            if case let .prepend(_, condition) = rule.rule, condition(command) { return rule }
            if case let .wrap(_, _, condition) = rule.rule, condition(command) { return rule }
            return nil
        }
        
        // Apply all standard rules
        var sandboxedCommand = command
        for rule in standardRules {
            sandboxedCommand = rule.apply(to: sandboxedCommand)
        }
        
        // Add AI generated indicator if applicable
        if isAIGenerated {
            sandboxedCommand = """
            echo "\\033[1;34m[AI-GENERATED] Executing command:\\033[0m"
            echo "\\033[34m\(sandboxedCommand.replacingOccurrences(of: "\"", with: "\\\""))\\033[0m"
            
            # AI-generated command
            \(sandboxedCommand)
            """
        }
        
        return sandboxedCommand
    }
    
    /// Applies permissive sandboxing measures (minimal security)
    /// - Parameter command: Original command
    /// - Returns: Sandboxed command
    private func applyPermissiveSandboxing(_ command: String) -> String {
        // In permissive mode, we still want to add basic safety for the most dangerous operations
        if commandIsHighRisk(command) {
            return """
            echo "\\033[1;33m[WARNING] About to execute potentially destructive command:\\033[0m"
            echo "\\033[33m\(command.replacingOccurrences(of: "\"", with: "\\\""))\\033[0m"
            echo -n "Press Enter to continue or Ctrl+C to cancel: "
            read
            
            # Command with basic safety
            \(command)
            """
        }
        
        return command
    }
    
    /// Determines if a command is high risk
    /// - Parameter command: Command to check
    /// - Returns: Whether the command is high risk
    public func commandIsHighRisk(_ command: String) -> Bool {
        let highRiskPatterns = [
            "rm -", "rmdir", "mv", "dd", "sudo",
            "format", "mkfs", "> /", "chmod", "chown"
        ]
        
        for pattern in highRiskPatterns {
            if command.contains(pattern) {
                return true
            }
        }
        
        return false
    }
    
    /// Creates an isolated environment for command execution
    /// - Parameters:
    ///   - command: Command to execute
    ///   - workingDirectory: Working directory for execution
    /// - Returns: Command wrapped in isolation
    public func createIsolatedEnvironment(
        for command: String,
        workingDirectory: String? = nil
    ) -> String {
        let workDir = workingDirectory ?? "$PWD"
        
        return """
        (
            # Begin isolated environment
            set -e
            
            # Create temporary directory
            ISOLATED_DIR="$(mktemp -d)"
            trap 'rm -rf "$ISOLATED_DIR"' EXIT
            
            # Set up working directory
            cd "\(workDir)"
            
            # Create environment isolation
            export HISTFILE=/dev/null
            export TMPDIR="$ISOLATED_DIR/tmp"
            mkdir -p "$TMPDIR"
            
            # Execute command in isolation
            \(command)
            
            # Clean up

