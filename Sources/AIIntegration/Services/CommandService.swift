import Foundation
import os.log

/// Source of a command in history
public enum CommandSource: String, Codable, Sendable {
    case user     // Entered by the user
    case system   // System command (not from user input)
    case auto     // Generated by Auto mode
    case dispatch // Generated by Dispatch mode
}
/// A history entry for a command with metadata for AI analysis
public struct CommandHistoryEntry: Codable, Identifiable, Equatable, Sendable {
    /// Unique identifier for the entry
    public let id: UUID
    
    /// The command string that was executed
    public let command: String
    
    /// The output of the command
    public let output: String?
    
    /// The exit code of the command
    public let exitCode: Int?
    
    /// When the command was executed
    public let timestamp: Date
    
    /// Duration of command execution in seconds
    public let duration: TimeInterval?
    
    /// Working directory where the command was executed
    public let workingDirectory: String?
    
    /// Command context for AI analysis (e.g., task category)
    public let context: [String: String]?
    
    /// Whether the command was AI-assisted
    public let isAIAssisted: Bool
    
    /// Source of the command
    public let source: CommandSource
    
    /// Creates a new command history entry
    /// - Parameters:
    ///   - command: The command that was executed
    ///   - output: Optional command output
    ///   - exitCode: Optional exit code
    ///   - timestamp: When the command was executed (defaults to now)
    ///   - duration: Optional duration of command execution
    ///   - workingDirectory: Optional working directory
    ///   - context: Optional context metadata
    ///   - isAIAssisted: Whether the command was AI-assisted
    public init(
        id: UUID = UUID(),
        command: String,
        output: String? = nil,
        exitCode: Int? = nil,
        timestamp: Date = Date(),
        duration: TimeInterval? = nil,
        workingDirectory: String? = nil,
        context: [String: String]? = nil,
        isAIAssisted: Bool = false,
        source: CommandSource = .user
    ) {
        self.id = id
        self.command = command
        self.output = output
        self.exitCode = exitCode
        self.timestamp = timestamp
        self.duration = duration
        self.workingDirectory = workingDirectory
        self.context = context
        self.isAIAssisted = isAIAssisted
        self.source = source
    }
    
    /// Creates a history entry from a command result
    /// - Parameters:
    ///   - result: The command result
    ///   - workingDirectory: Optional working directory
    ///   - context: Optional context metadata
    ///   - isAIAssisted: Whether the command was AI-assisted
    public init(
        from result: CommandResult,
        workingDirectory: String? = nil,
        context: [String: String]? = nil,
        isAIAssisted: Bool = false,
        source: CommandSource = .system
    ) {
        self.id = UUID()
        self.command = result.command
        self.output = result.output
        self.exitCode = result.exitCode
        self.timestamp = Date()
        self.duration = result.duration
        self.workingDirectory = workingDirectory
        self.context = context
        self.isAIAssisted = isAIAssisted
        self.source = source
    }
}

/// Service for executing commands and managing command history
public actor CommandService {
    /// Logger for tracking command service activity
    private let logger = Logger(subsystem: "com.llamaterminal", category: "CommandService")
    
    /// Maximum number of history entries to keep in memory
    private let maxHistoryEntries: Int
    
    /// Command execution service for executing shell commands
    private let executionService: any CommandExecutionServiceProtocol
    
    /// In-memory storage of command history
    private var commandHistory: [CommandHistoryEntry] = []
    
    /// Persistent storage key for command history
    private let historyStorageKey = "com.llamaterminal.command_history"
    
    /// File URL for history storage
    private let historyFileURL: URL
    
    /// Current working directory for commands
    private var currentWorkingDirectory: String
    
    /// Initializes a new CommandService
    /// - Parameters:
    ///   - executionService: Service for executing commands
    ///   - maxHistoryEntries: Maximum number of history entries to keep (default: 1000)
    ///   - historyDirectory: Directory for storing command history (default: Application Support)
    public init(
        executionService: any CommandExecutionServiceProtocol,
        maxHistoryEntries: Int = 1000,
        historyDirectory: URL? = nil
    ) {
        self.executionService = executionService
        self.maxHistoryEntries = maxHistoryEntries
        
        // Set up working directory
        self.currentWorkingDirectory = FileManager.default.currentDirectoryPath
        
        // Set up history file location
        let directory = historyDirectory ?? FileManager.default.urls(
            for: .applicationSupportDirectory,
            in: .userDomainMask
        ).first!.appendingPathComponent("LlamaTerminal", isDirectory: true)
        
        // Create directory if it doesn't exist
        try? FileManager.default.createDirectory(
            at: directory,
            withIntermediateDirectories: true
        )
        
        self.historyFileURL = directory.appendingPathComponent("command_history.json")
        
        // Load history from persistent storage
        self.commandHistory = loadHistoryFromFile()
        
        logger.info("CommandService initialized with \(self.commandHistory.count) history entries")
    }
    
    /// Executes a command using the execution service
    /// - Parameters:
    ///   - command: Command to execute
    ///   - context: Optional context metadata for AI analysis
    ///   - isAIAssisted: Whether the command was AI-assisted
    ///   - timeout: Optional timeout duration
    /// - Returns: Result of the command execution
    public func executeCommand(
        _ command: String,
        context: [String: String]? = nil,
        isAIAssisted: Bool = false,
        timeout: TimeInterval? = nil
    ) async throws -> CommandResult {
        // Validate command
        guard validateCommand(command) else {
            throw CommandServiceError.invalidCommand
        }
        
        let startTime = Date()
        
        // Execute command
        logger.info("Executing command: \(command)")
        let result = try await executionService.executeCommand(command, timeout: timeout)
        
        // Create and store history entry
        let historyEntry = CommandHistoryEntry(
            from: result,
            workingDirectory: currentWorkingDirectory,
            context: context,
            isAIAssisted: isAIAssisted
        )
        
        addToHistory(historyEntry)
        
        return result
    }
    
    /// Executes a command and streams the output in real-time
    /// - Parameters:
    ///   - command: Command to execute
    ///   - context: Optional context metadata for AI analysis
    ///   - isAIAssisted: Whether the command was AI-assisted
    ///   - timeout: Optional timeout duration
    /// - Returns: Stream of command output chunks and final result
    public func executeCommandWithStreaming(
        _ command: String,
        context: [String: String]? = nil,
        isAIAssisted: Bool = false,
        timeout: TimeInterval? = nil
    ) -> AsyncThrowingStream<CommandOutputChunk, Error> {
        // Validate command
        guard validateCommand(command) else {
            return AsyncThrowingStream { continuation in
                continuation.finish(throwing: CommandServiceError.invalidCommand)
            }
        }
        
        logger.info("Executing streaming command: \(command)")
        
        // Start time for tracking duration
        let startTime = Date()
        
        // Get output stream from execution service
        let outputStream = executionService.executeCommandWithStreaming(command, timeout: timeout)
        
        // Return a new stream that captures the final result for history
        return AsyncThrowingStream { continuation in
            Task {
                do {
                    var lastOutput = ""
                    var exitCode: Int?
                    var duration: TimeInterval?
                    
                    // Forward each chunk to the caller
                    for try await chunk in outputStream {
                        continuation.yield(chunk)
                        
                        // If it's a completion chunk, store the command result
                        if chunk.isComplete, let chunkExitCode = chunk.exitCode {
                            exitCode = chunkExitCode
                            duration = chunk.duration
                        } else if !chunk.content.isEmpty {
                            // Accumulate non-empty output
                            if !lastOutput.isEmpty {
                                lastOutput += "\n"
                            }
                            lastOutput += chunk.content
                        }
                    }
                    
                    // Create and store history entry
                    if let exitCode = exitCode {
                        let result = CommandResult(
                            command: command,
                            output: lastOutput,
                            exitCode: exitCode,
                            duration: duration ?? Date().timeIntervalSince(startTime)
                        )
                        
                        let historyEntry = CommandHistoryEntry(
                            from: result,
                            workingDirectory: currentWorkingDirectory,
                            context: context,
                            isAIAssisted: isAIAssisted
                        )
                        
                        await addToHistory(historyEntry)
                    }
                    
                    continuation.finish()
                } catch {
                    logger.error("Error executing streaming command: \(error.localizedDescription)")
                    continuation.finish(throwing: error)
                }
            }
        }
    }

    /// Checks if a command is valid
    /// - Parameter command: Command to validate
    /// - Returns: Whether the command is valid
    public func validateCommand(_ command: String) -> Bool {
        return !command.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    
    /// Sets the current working directory
    /// - Parameter path: Directory path
    public func setWorkingDirectory(_ path: String) {
        self.currentWorkingDirectory = path
    }
    
    /// Gets the current working directory
    /// - Returns: Directory path
    public func getWorkingDirectory() -> String {
        return currentWorkingDirectory
    }

    /// Gets history of recent commands
    /// - Parameter limit: Maximum number of history entries to return
    /// - Returns: Array of recent command history entries
    public func getRecentCommands(limit: Int = 10) -> [CommandHistoryEntry] {
        let count = min(limit, commandHistory.count)
        let endIndex = commandHistory.count
        let startIndex = max(0, endIndex - count)
        
        return Array(commandHistory[startIndex..<endIndex])
    }
    
    /// Searches command history for entries matching the query
    /// - Parameters:
    ///   - query: Search query
    ///   - limit: Maximum number of results to return
    ///   - filter: Optional filter to apply (e.g., successful commands only)
    /// - Returns: Array of matching history entries
    public func searchHistory(
        query: String,
        limit: Int = 20,
        filter: CommandHistoryFilter = .all
    ) -> [CommandHistoryEntry] {
        // Apply basic filtering first
        var filteredEntries = commandHistory
        
        switch filter {
        case .all:
            // No filtering needed
            break
        case .successful:
            filteredEntries = filteredEntries.filter { $0.exitCode == 0 }
        case .failed:
            filteredEntries = filteredEntries.filter { $0.exitCode != 0 && $0.exitCode != nil }
        case .aiAssisted:
            filteredEntries = filteredEntries.filter { $0.isAIAssisted }
        case .dateRange(let start, let end):
            filteredEntries = filteredEntries.filter {
                $0.timestamp >= start && $0.timestamp <= end
            }
        }
        
        // If no query, just return the filtered entries up to limit
        if query.isEmpty {
            let count = min(limit, filteredEntries.count)
            return Array(filteredEntries.suffix(count))
        }
        
        // Apply search with scoring
        let searchResults = filteredEntries.compactMap { entry -> (entry: CommandHistoryEntry, score: Int)? in
            let commandLower = entry.command.lowercased()
            let queryLower = query.lowercased()
            
            // Exact match gets highest score
            if commandLower == queryLower {
                return (entry, 100)
            }
            
            // Starts with query gets high score
            if commandLower.hasPrefix(queryLower) {
                return (entry, 75)
            }
            
            // Contains query gets medium score
            if commandLower.contains(queryLower) {
                return (entry, 50)
            }
            
            // Words in command contain query gets low score
            let words = commandLower.split(separator: " ")
            if words.contains(where: { $0.hasPrefix(queryLower) }) {
                return (entry, 25)
            }
            
            // No match
            return nil
        }
        
        // Sort by score and get top results
        let sortedResults = searchResults.sorted { $0.score > $1.score }
        let limitedResults = sortedResults.prefix(limit)
        
        return limitedResults.map { $0.entry }
    }
    
    /// Gets commands similar to the provided command
    /// - Parameters:
    ///   - command: Command to find similar entries for
    ///   - limit: Maximum number of similar commands to return
    /// - Returns: Array of similar commands from history
    public func getSimilarCommands(_ command: String, limit: Int = 5) -> [String] {
        // Extract the command name (first word)
        let commandName = command.split(separator: " ").first?.lowercased() ?? ""
        if commandName.isEmpty {
            return []
        }
        
        // Find commands that start with the same command name
        let similarCommands = commandHistory
            .filter { $0.command.lowercased().hasPrefix(commandName) }
            .filter { $0.command != command } // Exclude exact match
            .sorted { $0.timestamp > $1.timestamp } // Most recent first
            .prefix(limit)
            .map { $0.command }
        
        return Array(similarCommands)
    }
    
    /// Adds an entry to command history
    /// - Parameter entry: History entry to add
    private func addToHistory(_ entry: CommandHistory
